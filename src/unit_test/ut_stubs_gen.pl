#!/usr/bin/env perl
# /ADK/src/unit_test/ut_stubs_gen.pl
#
# This file is a part of ADK library.
# Copyright (c) 2012, Artyom Lebedev <artyom.lebedev@gmail.com>
# All rights reserved.
# See COPYING file for copyright details.

# This tool automatically generates stubs for all unreferenced symbols in order
# satisfy unit tests linking.

use File::Basename;
use Getopt::Long;

$NM = "nm";
$CPPFILT = "c++filt";
$result_name = "auto_stubs.cpp";
@SRCS = ( );
@TEST_SRCS = ( );

# All globally defined symbols
%defined_syms = ( );
# All undefined symbols
%wanted_syms = ( );
# Prohibited symbols
%prohibited_syms = ( "__dso_handle" => 1);

sub ParseFile {
    my ($filename, $isTest, $isDynamicLib) = @_;
    
    if ($isDynamicLib) {
        open(NM, "$NM -D $filename |") or die("Failed to open file '$filename'");
    } else {
        open(NM, "$NM $filename |") or die("Failed to open file '$filename'");
    }
    
    while (my $line = <NM>) {
        if ($line =~ /^\s*[0-9a-fA-F]*\s+([TDUBWV])\s+(.*)$/) {
            if ($1 eq "T" or $1 eq "D" or $1 eq "B" or $1 eq "W" or $1 eq "V") {
                $defined_syms{$2} = $filename;
            } elsif ($1 eq "U" and $isTest) {
                if ($2 !~ /__cxa|__cxx|__gxx|_Unwind_/) {
                    $wanted_syms{$2} = $filename;
                }
            }
        }
    }
    close(NM);
}

sub FindLib {
    my ($libname) = @_;
    # Firstly try exact match for default library
    for my $dir (@LIB_DIRS) {
        my $file = "$dir/lib${libname}.so";
        if ( -e $file) {
            return $file;
        }
    }
    # Take the first match with version number
    for my $dir (@LIB_DIRS) {
        @files = glob("$dir/lib${libname}.so.*");
        if (@files) {
            return @files[0]
        }
    }
    die("Library not found: $libname")
}

sub ProcessLib {
    my ($libname) = @_;
    my $file = FindLib($libname);
    ParseFile($file, 0, 1);
}


sub ResolveSymbols {
    for my $name (keys %wanted_syms) {
        if (defined $defined_syms{$name} or defined $prohibited_syms{$name}) {
            delete $wanted_syms{$name};
        }
    }
}

sub DemangleName {
    my ($name) = @_;
    open(CPPFILT, "$CPPFILT $name |") or die ("Cannot open c++filt");
    my $readable_name = <CPPFILT>;
    close(CPPFILT);
    chomp($readable_name);
    return $readable_name;
}

sub CreateOutput {
    open(RESULT, "> $result_name") or die("Cannot open output file '$result_name'");
    
    my $header = <<EOF;
/* This file is automatically generated by ADK unit testing framework.
 * Do not edit it manually!
 */

#include <adk_ut.h>

#define SYM_STUB(idx, name, readable_name, wanted_by) \\
    namespace ut { \\
    void ut_auto_stub_ ## idx() asm(name); \\
    void ut_auto_stub_ ## idx() { \\
        UT_FAIL("Auto-generated stub for '" readable_name "' called\\n" \\
                "(referenced from '" wanted_by "')"); \\
    } \\
    } /* namespace ut */

EOF

    print(RESULT $header);
    
    my $symIdx = 0;
    for my $name (keys %wanted_syms) {
        my $readable_name = DemangleName($name);
        
        print(RESULT "SYM_STUB($symIdx,\n\t\"$name\",\n\t\"$readable_name\",\n\t\"$wanted_syms{$name}\")\n");
        $symIdx++;
    }

    close(RESULT);
    print("Stubs for $symIdx symbols generated\n");
}

GetOptions(
    "nm=s" => \$NM,
    "cppfilt=s" => \$CPPFILT,
    "result=s" => \$result_name,
    "src=s" => \@SRCS,
    "test_src=s" => \@TEST_SRCS,
    "lib-dir=s" => \@LIB_DIRS,
    "lib=s" => \@LIBS
);

for my $file (@TEST_SRCS) {
    ParseFile($file, 1, 0);
}

for my $file (@SRCS) {
    ParseFile($file, 0, 0);
}

for my $lib (@LIBS) {
    ProcessLib($lib);
}

ResolveSymbols();

CreateOutput();
